# %%
'''
# Parse Raw Data

## Information

- FileName: parse_raw_data.py
- Author: Chuncheng Zhang
- Date: 2021-04-27

## Data Description

The raw motion data is in single .csv format.

The raw motion data are of 120 features.
The 120 features are generated by 6 channels x 20 time points.
- The 6 channels are position difference on 3 axes dx, dy, dx and 3 angle difference rotating with the 3 axes;
- The 20 time points are linear separated by 200 ms for each two time points.

The raw motion data has thousands of samples.
The samples are labeled as 9 motion events.
- 1-SLW: Slow-speed Level Walking;
- 2-MLW: Medium-speed Level Walking;
- 3-FLW: Fast-speed Level Walking;
- 4-RD: Ramp Descending;
- 5-SD: Stair Descending;
- 6-sit: Sitting Down;
- 7-stand: Standing Up;
- 8-RA: Ramp Ascending;
- 9-SA: Stair Ascending.

## Analysis

The script will **Parse** the raw motion data and **Visualize** it in 2D space.

### Parse

The raw motion will be read and the data of different motion events will be separated.
The separated motion data will be transformed from
the shape of (s x 120) to the shape of (s x 20 x 6),
where the 20 refers the 20 time points and the 6 refers the 6 channels.
The parsed data will be saved into the separated .npy file named as their events,
like 1-SLM.npy.

### Visualize

To generate the visualization of the relationship between the motion events.
The TSNE bedding method is usd to project the 120 features data into 2D manifold spaces.
The projected samples will be drawn into the 2D space.

Since there are too many samples, it is impossible to draw all of them.
In practice, the data are randomized averaged to formulate less samples to be drawn.
The projected 2D features and the plot will be saved when the script is operated.

- The 2D features data will be saved as "TSNE Plot.csv";
- The Plot will be saved as "TSNE Plot.html".
'''

# %%
# Required Packages
import os
import numpy as np
import pandas as pd
import plotly.express as px

from sklearn.manifold import TSNE

# %%
# Define event names and their labels
event_name = {
    "1-SLW": 1,
    "2-MLW": 2,
    "3-FLW": 3,
    "4-RD": 4,
    "5-SD": 5,
    "6-sit": 6,
    "7-stand": 7,
    "8-RA": 8,
    "9-SA": 9,
}

raw_csv_name = '处理后的数据(200ms)(6个人).csv'

# %%
# Where the data will be read from and saved to.
folder = os.path.join(os.environ['Sync'], 'MotionData', 'dataFolder')


def generate_path(last, folder=folder):
    '''
    Generate path based on [folder] and [last],
    the [last] will be tailed to the [folder] string.
    It will raise a warning message if the new path has been already a file.

    Args:
    - @last: The last part of the new path.
             If it is a list, it will be jointed together in the given order;
    - @folder: The folder part of the new path, it has default value.

    Outputs:
    - @output: The generated path string.
    '''

    if isinstance(last, list):
        last = os.path.sep.join(last)

    output = os.path.join(folder, last)

    if os.path.isfile(output):
        print(f'W: File exits: "{output}"')

    return output


def save(method, path, *args, **kwargs):
    '''
    Save to [path] using [method].

    Args:
    - @method: The method of saving;
    - @path: The path of saving.
    '''
    if os.path.isfile(path):
        print(f'W: Overriding existing file: "{path}"')

    method(path, *args, **kwargs)
    a = f'{args}'[:10]
    b = f'{kwargs}'[:10]
    print(f'I: Saved file: "{path}", with parameters of {a} and {b}')


raw_csv = generate_path(raw_csv_name)

# %%
# Read the raw data into a DataFrame
df_raw = pd.read_csv(raw_csv, header=None)
print(f'D: The raw data has "{len(df_raw)}" rows.')
df_raw

# %%
'''
Parse the raw data into separated events,
and save them into .npy files.

Additionally,
data_3d dict will be generated,
- The keys are the event names;
- The values are the s x 20 x 6 matrix.
'''
data_3d = dict()
for evt in event_name:
    e = event_name[evt]
    df = df_raw[df_raw[0] == e]

    values = df.values
    event = values[:, 0]
    data = values[:, 2:]

    shape = data.shape
    new_shape = (data.shape[0], int(data.shape[1] / 6), 6)
    data3 = np.zeros(new_shape)
    for i in range(shape[0]):
        data3[i] = data[i].reshape((new_shape[1], new_shape[2]))
    print(f'D: Parsed "{data.shape}" into "{data3.shape}"')

    save(np.save, generate_path(f'{evt}.npy'), data3)

    data_3d[evt] = data3

for k in data_3d:
    print(f'I: The "{k}" has data shape "{data_3d[k].shape}"')

# %%
# Inner functions


def select_batch(k, ravel=True):
    '''
    Inner function of fetching [k] samples for each motion events,
    the [k] samples are averaged and returned.

    Args:
    - @k: The number of the required samples;
    - @ravel: Option for raveling the samples,
              if False, the original samples will be used;
              if True, the raveled samples will be used;
              the default value is True.

    Requires:
    - @data_3d: The data dict for each motion events.

    Outputs:
    - @data_batch: The dict of data for motion events.
    '''
    data_batch = []
    for e in event_name:
        d = np.random.permutation(data_3d[e])[:k]
        m = np.mean(d, axis=0)
        if ravel:
            m = np.ravel(m)
        data_batch.append((m, e))
    return data_batch


def add_df(df, data_batch, k):
    '''
    Add entries ([data_batch] with size of [k]) to the DataFrame [df].

    Args:
    - @df: The DataFrame to be added into;
    - @data_batch: The data_batch from @select_batch;
    - @k: The number option of generating [data_batch].

    Outputs:
    - @df: The added DataFrame, it will contain three columns:
           - event: The event name;
           - k: The k value;
           - feature: The features vector..
    '''
    for de in data_batch:
        d, e = de
        df = df.append(pd.Series(dict(
            feature=d,
            event=e,
            k=k
        )), ignore_index=True)

    df = df[['event', 'k', 'feature']]

    return df


# %%
'''
Generate the DataFrame with different sample sizes [k].
- The [k] values refer the confidential level, the larger [k] refers higher confidential level;
- We generate 10 samples for k = 2000, 1000, and 500 and generate 100 samples for k = 100.

Generate:
- @df: The generated DataFrame, it has three columns:
       - event: The event name;
       - k: The k value;
       - feature: The features vector.
'''
df = pd.DataFrame()

for j in range(10):
    k = 2000
    data_batch = select_batch(k=k)
    df = add_df(df, data_batch, k)

for j in range(10):
    k = 1000
    data_batch = select_batch(k=k)
    df = add_df(df, data_batch, k)

for j in range(10):
    k = 500
    data_batch = select_batch(k=k)
    df = add_df(df, data_batch, k)

for j in range(100):
    k = 100
    data_batch = select_batch(k=k)
    df = add_df(df, data_batch, k)

print(f'I: Generate averaged data as "{len(df)}" samples')
df

# %%
'''
TSNE analysis to the data of [df]

Generate:
- @dp: The 2D samples in 2D manifold space.
'''
d = np.array([e for e in df['feature']])
tsne = TSNE(n_components=2)
dp = tsne.fit_transform(d)
d.shape, dp.shape

# %%
'''
Plot and Save the [df]

Generate:
- @fig: The Ploting of the manifold space;
- @"TSNE Plot.csv": The averaged feature file;
- @"TSNE Plot.html": The ploting of the averaged features in the manifold space.
'''
df['x'] = dp[:, 0]
df['y'] = dp[:, 1]
title = 'TSNE Plot'
fig = px.scatter(df, x='x', y='y', color='event',
                 size='k', opacity=0.4, title=title)
# fig.show()
save(fig.write_html, generate_path(f'{title}.html'))
save(df.to_csv, generate_path(f'{title}.csv'))

# %%
